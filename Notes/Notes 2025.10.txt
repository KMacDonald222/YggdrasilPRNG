YggdrasilPRNG Development Notes 2025.10
2025.10.15@10:10ADT

2025.10.15:

@10:01ADT: Setting up the basics of the building/testing workflow for this
project. There will eventually be two driver programs, but only one will be used
for now for testing during development of the YggdrasilPRNG library. This will
test the process of building the library into an archive (for Linux only, but
eventually other platforms), including and linking it in the YGen generator
driver program, and running some of its code.

@11:06ADT: The build/test workflow is now up and running as described above. Now
the intended function of the initial two projects can be planned out here:

YggdrasilPRNG:

The PRNG library will contain all the logic of the PRNG itself
which is based on a tree data structure containing nodes which produce and mix
together PRNG data from Galois LFSRs with different widths and tap positions.
Other than the LFSR nodes, the tree will also contain AND, OR, and XOR nodes
which combine the outputs of their children with boolean operations, and matrix
notes which swaps some bits of the outputs of their children. The root node of
the tree (always an XOR node to ensure approximately uniform distribution of
output bits) will be the source of PRNG data for the whole library, the internal
nodes will be pseudorandomly generated as XOR, AND, OR, or matrix nodes, and the
leaf nodes will always be LFSR nodes.

The main class (a wrapper for this tree data structure) and each of the node
classes will have seed, generate, and clear functions. The seed function
generally initializes memory with a seed value (some string of data), the
generate function generally produces a single byte PRNG output, and the clear
function deinitializes memory.

Wrapper:
- Seed: Takes in a string of seed data and a number of layers to generate in the
tree and creates and calls the seed function of the root XOR node with these
same parameters (subtracting 1 from the layer count)
- Generate: Returns the output of the root XOR node's generate function
- Clear: Calls the root XOR node's generate function

XOR node:
- Seed: Takes in a string of seed data and a number of layers to generate in the
tree below the current one then computes the SHA-512 hash of the seed value.
If the number of layers to generate below this layer is greater than 1; this
function creates 1-4 XOR node children using the 508th and 509th bits of the
hash, 0-1 AND node children using the 510th bit of the hash, 0-1 OR node
children using the 511th bit of the hash, and 1-2 matrix node children using the
512th bit of the hash. Otherwise, this function creates 5-8 LFSR node children
using the 511th and 512th bits of the hash. Finally, this function seeds each of
the child nodes with a permuted version of the seed data and one less than the
layer count.
- Generate: Calls the generate function of each child node and returns their
boolean XOR combination.
- Clear: Calls the clear function of each child node.

AND node:
- Seed: Takes in the same data as in the XOR node and computes the SHA-512 hash.
If the number of layers to generate below this layer is greater than 1; this
function creates 1-2 XOR node children using the 510th bit of the hash, 0-1 OR
node children using the 511th bit of the hash, and 1-2 matrix node children
using the 512th bit of the hash. Otherwise, this function creates 2-5 LFSR node
children using the 511th and 512th bits of the hash. Then the children are
seeded as in the XOR node.
- Generate: Same as XOR node but with AND operation.
- Clear: Same as XOR node.

OR node:
- Seed: Same as the AND node's seed function but creates 0-1 AND node children
instead of OR
- Generate: Same as XOR node but with OR operation.
- Clear: Same as XOR node.

Matrix node:
- Seed: Takes in the same data as in the XOR node and computes the SHA-512 hash.
Generates the same counts of children as the XOR node using the same bits of the
hash. Seeds each of the child nodes as in the XOR node. Finally, this function
will generate an 8x8 matrix of integers and populate its columns by repeating
the following shift procedure 8 times:
1. Getting a byte generated by the populating child (initially the first child)
generated and using it to select a pseudorandom child node mod the number of
children, which will become the next populating child
2. Shifting the matrix's columns one to the right (discarding the rightmost
column).
3. Populate the leftmost column of the matrix with the next output byte of the
newly selected populating child replacing 0's with -1's.
- Generate: Performs the shift procedure once and gets an additional byte of
output from the populating child and converts it to an 8-vector of 1's and 0's.
Computes the matrix-vector product of the current matrix and the output byte.
For each element of the product vector greater than 2, set the corresponding bit
of the output byte to 1, and for each element less than -2, set the
corrsponding output but to 0.
- Clear: Overwrite and free the matrix's memory then call the clear function of
all child nodes.

LFSR node:
- Seed: Takes in the same data as in the XOR node and computes the SHA-512 hash.
Uses the 509th, 510th, 511th, and 512th bits of the hash to select one of 16
LFSR configuration presets for width and tap positions and initializes an LFSR
with the configuration in memory. Populates the LFSR buffer with the most
significant bits of the hash (repeating if with width is greater than 512 bits).
- Generate: Produces a byte of output by sampling the least significant bit of
the LFSR in normal operation (see reference paper on LFSRs).
- Clear: Overwrites and frees the memory of the LFSR buffer.

The seed functions of the XOR, AND, OR, and matrix nodes depend on permuting and
padding the seed string, which will be done as follows:
1. Compute the SHA-512 hash of the seed string, represented in hexadecimal.
2. Append the most significant digits of the hex hash until the string's length
is the next multiple of 8.
3. Break the seed into n chunks of 4 characters and for each chunk:
    a. Compute the SHA-512 hash of the chunk.
    b. Use the 509th, 510th, 511th, and 512th bits of the hash to select one of
    16 permutations of 4 objects.
    c. Apply the permutation to the chunk.
4. Concatenate the chunks of 4 characters in their original order and compute
the new string's hash and use the 509th, 510th, 511th, and 512th bits of the
hash to select one of 16 permutations of 8 objects.
5. Break the new string into 8 chunks of n characters and apply the permutation
of 8 objects to the chunks.
6. Concatenate the chunks together again and return the permuted/padded string.

The operation of the LFSR node is described in the attached paper in the
References directory "Table of Linear Feedback Shift Registers.pdf". The SHA-512
algorithm implemented in C++ is sourced from the GitHub user Filip
Dobrosavljevic (pr0f3ss)'s SHA repository.

YGen:

This program will simply be a testing driver for the Yggdrasil PRNG library for
now and will later be changed into a driver program which uses the PRNG to
output data to the console and to files in various formats including
strings/characters, integers, floating point numbers, binary, and hexadecimal.

@23:31ADT: The next task in the implementation of the library will be to ensure
that the SHA vendor library is included and working. With this working now, a
Tests directory will be created to store scripts showing working tests of the
project at different stages.

@23:51ADT: This test is done and the vendor library is working - uploading the
LFSR reference material and the test script.

2025.10.16:

@11:17ADT: The next part of the PRNG library to implement will be the abstract
node class and the LFSR class which will inherit some code from it. The abstract
node class has only the three generate, seed, and clear functions and a set of
pointers to the node's children and will be the parent class of each of the five
other node types.

A utilities module will also be implemented to provide wrapper functions for the
SHA vendor library and eventually the string padding/permutation function
described above.

@15:03ADT: The abstract node class is implemented and the project can move on to
these utility functions - the permutation and SHA functions. SHA functions will
be set up first since they're simpler.

2025.10.18:

@00:42ADT: Running the test script for the SHA-512 vendor library wrapper
functions and then committing work for so far. The next part to set up is the
padding and permutation function described above, this will use the SHA-512
wrapper functions but nothing else.

The 16 permutations of 4 and 8 objects will be selected by the Permutation
Generator Python script in the Scripts directory of this project. A script of
this running will be placed in the tests. This script selects a number of
permutations of a number of objects with Python 3's built-in random module,
ensures that no two permutations selected are the same, and then prints them in
the C++ array initializer format so they can be hardcoded into the utilities
module.

@09:26ADT: The permutations were generated last night, and they are now in the
Utilities module. The permuteString utility function will now be implemented.

2025.10.19:

@21:05ADT: Continuing the implementation of the string padding/permutation
function. Console output throughout the whole process will be added to show the
function running and then a test will be created.

@22:48ADT: Interrupting this process to ensure that, as in the concept for the
clear function for node types, all sensitive memory - as soon as it's done being
used - is overwritten with 0's before it is deleted.

The padding and permutation function is working as intended, and has its tests
implemented. The current code will all be reviewed to overwrite all sensitive
memory.

2025.10.20:

@17:16ADT: Going through the entire code base so far and checking for sensitive
information to overwrite before releasing from the stack back to the system. The
YGen test implementation will be excluded from this since it will consistently
change.

2025.10.21:

@12:36ADT: The implementation of the utility function with memory safety is
finished and can now be tested. A script will be placed in the Tests directory
showing the function's operation on a "Hello World!" string, then the console
output will be removed, the function tested again to ensure the same output, and
the code will be uploaded.

@12:50ADT: The next thing to do is to add the LFSR node type, which will be the
simplest since it has no children and its operation is well described.

@18:43ADT: The LFSR node type is being created now. The LFSR configurations for
buffer width and tap positions are selected in the seed function of this node
type by the hash of the seed from a pre-defined set of 16 configurations. The
configurations used here are drawn from the set of max-period Galois LFSRs based
on their widths having subjectively satisfying digit patterns - these could be
considered magic numbers in security/cryptographic considerations. Generally,
the configurations selected are on the larger side to increase the periods of
the LFSRs.

@22:13ADT: The LFSR configurations have been selected. For those selected that
have four and two-tap configurations, both have been included in the selection.
The widths of the configurations were selected for the following reasons:
- 4096, 2048, and 1024 because they are the biggest available in the table given
by the paper,
- 777, 666, 555, 444, and 333 because they have repeated digits,
- 404 because it is a commonly known HTTP error code, and
- 419, 303, and 222 because of their personal significance to the author (magic
numbers).

The LFSR node's functions will now be implemented and tested. For testing
purposes, the width 419 configuration will be replaced with width 8 to simplify
output in the console. After this implementation, the same memory overwriting
procedure will be done as before.

@22:54ADT: The LFSR node is working and the code can now be cleaned.

@23:27ADT: The code cleaning is now done, a test script will be generated, the
code will be finalized, and then this part will be uploaded. The next part to
set up will be the matrix node type since this will be more complex than the
other remaining types - this will be done tomorrow.

2025.10.22:

@09:11ADT: Starting the implementation of the matrix node type (as described
above). This node type will be tested by generating only LFSR children since
these are the only type yet available.

@12:20ADT: The matrix node type appears to be working based on console output
and now the code cleanup can be done.

@13:25ADT: The code cleanup is done now and things are working the same as they
were before. The only thing left to implement in the MatrixNode class is the
generation of the other three types of nodes as children because they're not
available yet. The three of them, because they're so simple, similar, and yet
hard to test on their own, will be the next part of this project implemented.

The current code is being uploaded with placeholders where other child types
would normally be generated. The other three node types can now be added.

@14:00ADT: Pausing work while doing documentation for the three new nodes types
in the Nodes.h file. The matrix node class is finished with the skeletons of the
node types. These will all be very similar and will be developed in parallel.
The generate functions are especially easy, and the clear functions are exactly
the same as the abstract node and so are not overridden in any of the three.

@16:21ADT: Resuming work on this until @17:30ADT and continuing with the
documentation of the XOR, AND, and OR node types. Each of the generate functions
will be implemented first since they're simpler. These are done @16:40ADT,
moving on to the seed functions then testing.

@17:05ADT: This is done and a full test of the PRNG library can now be done by
implementing the main YggdrasilPRNG class. There is no sensitive memory that can
be overwritten in any of the three new classes.

@17:18ADT: This is all working now, a test will be generated in the Tests
directory and this code will be uploaded, then the next steps will be planned
out here.

The next part is to run some statistical tests on the output of the PRNG library
to check that everything is working satisfactorily. This will be done using the
tests described in the U.S. NIST Special Publication 800-22 Revision 1a - this
document will be copied into the References directory as "NIST SP 800-22 Rev.
1a.pdf". The NSA has been known to interfere with the security of NIST
standards, but if one is worried about the NSA reading their communications then
they either are not using this program or they are very foolish - and either way
are not the author's concern. These tests, implemented in Python, will be added
as a submodule from the GitHub user David Johnston (dj-on-github)'s
sp800_22_tests repository. This will be added in the Tests directory under
Statistical_Tests.

@17:47ADT: Stopping work again on this for now and committing the documentation.

@22:44ADT: To run these tests the YGen program will be converted to write binary
data from the Yggdrasil PRNG initialized with random seed values and 4 PRNG tree
layers to files. These tests require 1028016b = 128502B of data to have
statistical reliability. Since the number of possible seeds is inexhaustible,
the program will be made to run overnight tonight until 2025.10.23@~08:00ADT.
This new YGen program will be implemented now, tested, and the code committed
before the data generation is started tonight. The new YGen program will also
measure the time required to generate each file and compute the average time
that they take - giving a metric of how fast the 4-layer tree generally is.

After the data files are generated, a script will be written to pass them each
into the NIST tests and print the results to their own files and then another
script will compile the pass/fail rates of each of the NIST tests across the
whole data set.

2025.10.23:

@00:04ADT: This implementation of the YGen program is now finished and the test
can begin. The code will be uploaded first then a script will be started and the
new YGen program will be allowed to run overnight to generate as many data files
as it can before @~08:00ADT.

@09:11ADT: The 100th data file just finished generating. The data will now be
uploaded to the GitHub repository. The average time these files took to
generate was ~325s = ~5m25s giving an average speed of ~395B/s. This speed will
slow down exponentially as the number of layers in the tree grows, but four
layers is satisfactory.

Upon inspection of some of the generated data, the randomness is also
satisfactory, but this will be tested today.

@10:50ADT: The script to run the statistical tests is now finished and can now
be run with a tracking script in the Tests directory.

@11:49ADT: The results are all generated and they can now be compiled. The
results text files will be uploaded to GitHub before another script is added for
this.

@13:23ADT: A script will now be created to compile the pass/fail rates of each
of the 15 NIST tests from the results text files. This is done @13:36ADT and a
script showing this result will now be uploaded.

All of the tests passed very reliably except for the random excursion and random
excursion variant tests. This is an acceptable result for this project.